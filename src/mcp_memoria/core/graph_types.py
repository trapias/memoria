"""Type definitions for the knowledge graph feature.

This module defines the data models and enums for memory relations,
supporting typed relationships between memories stored in Qdrant.
Relations are persisted in PostgreSQL for efficient graph traversal.
"""

from datetime import datetime, timezone
from enum import Enum
from typing import Any
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, field_validator


class RelationType(str, Enum):
    """Types of relationships between memories in the knowledge graph.

    These relationship types enable semantic linking of memories,
    supporting both explicit user-created and AI-inferred connections.
    """

    # Causal relationships
    CAUSES = "causes"  # A leads to B
    FIXES = "fixes"  # A resolves/fixes B (typical: solution -> problem)

    # Logical relationships
    SUPPORTS = "supports"  # A confirms/supports B
    OPPOSES = "opposes"  # A contradicts B

    # Temporal relationships
    FOLLOWS = "follows"  # A follows B chronologically
    SUPERSEDES = "supersedes"  # A replaces B (fact update)

    # Structural relationships
    DERIVES = "derives"  # A is derived from B (e.g., consolidation)
    PART_OF = "part_of"  # A is part of B

    # Generic
    RELATED = "related"  # Generic correlation


class RelationDirection(str, Enum):
    """Direction for querying relations."""

    OUTGOING = "out"  # Relations where the memory is source
    INCOMING = "in"  # Relations where the memory is target
    BOTH = "both"  # Both directions


class RelationCreator(str, Enum):
    """Who/what created the relation."""

    USER = "user"  # Manually created by user
    AUTO = "auto"  # AI suggested and accepted
    SYSTEM = "system"  # Created by system (e.g., consolidation)
    AI_SUGGESTED = "ai_suggested"  # Suggested but not yet confirmed


class Relation(BaseModel):
    """A single relation between two memories.

    Represents a directed edge in the knowledge graph, stored in PostgreSQL
    for efficient traversal with WITH RECURSIVE queries.
    """

    model_config = ConfigDict(
        populate_by_name=True,
        from_attributes=True,
    )

    # Relation identifier
    id: UUID | None = None

    # Source and target memory IDs
    source_id: UUID
    target_id: UUID

    # Relation properties
    relation_type: RelationType = Field(alias="type")
    weight: float = Field(default=1.0, ge=0.0, le=1.0)

    # Metadata
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    created_by: RelationCreator = RelationCreator.USER
    metadata: dict[str, Any] = Field(default_factory=dict)

    @field_validator("source_id", "target_id", mode="before")
    @classmethod
    def validate_uuid(cls, v: Any) -> UUID:
        """Convert string UUIDs to UUID objects."""
        if isinstance(v, str):
            return UUID(v)
        return v

    def model_dump_for_api(self) -> dict[str, Any]:
        """Serialize for API responses."""
        return {
            "id": str(self.id) if self.id else None,
            "source_id": str(self.source_id),
            "target_id": str(self.target_id),
            "type": self.relation_type.value,
            "weight": self.weight,
            "created_at": self.created_at.isoformat(),
            "created_by": self.created_by.value,
            "metadata": self.metadata,
        }


class RelationWithContext(Relation):
    """Relation with context from the linked memory.

    Extends Relation with content from the related memory,
    fetched from Qdrant when context is requested.
    """

    # Linked memory details (populated from Qdrant)
    linked_memory_id: str | None = None
    linked_memory_content: str | None = None
    linked_memory_type: str | None = None
    linked_memory_tags: list[str] = Field(default_factory=list)
    linked_memory_importance: float | None = None

    def model_dump_for_api(self) -> dict[str, Any]:
        """Serialize for API responses with context."""
        base = super().model_dump_for_api()
        base.update({
            "linked_memory": {
                "id": self.linked_memory_id,
                "content": self.linked_memory_content,
                "type": self.linked_memory_type,
                "tags": self.linked_memory_tags,
                "importance": self.linked_memory_importance,
            }
            if self.linked_memory_id
            else None
        })
        return base


class RelationSuggestion(BaseModel):
    """AI-suggested relation between memories.

    Generated by analyzing content similarity and semantic patterns
    to suggest potential relationships.
    """

    model_config = ConfigDict(from_attributes=True)

    # Target memory for suggested relation
    target_id: str
    target_content: str = ""
    target_tags: list[str] = Field(default_factory=list)
    target_type: str | None = None

    # Suggested relation
    suggested_type: RelationType = RelationType.RELATED
    confidence: float = Field(default=0.0, ge=0.0, le=1.0)
    reason: str = ""

    def model_dump_for_api(self) -> dict[str, Any]:
        """Serialize for API responses."""
        return {
            "target_id": self.target_id,
            "target_content": self.target_content[:200] + "..."
            if len(self.target_content) > 200
            else self.target_content,
            "target_tags": self.target_tags,
            "target_type": self.target_type,
            "suggested_type": self.suggested_type.value,
            "confidence": round(self.confidence, 3),
            "reason": self.reason,
        }


class GraphNode(BaseModel):
    """Node in the knowledge graph for visualization.

    Represents a memory as a node in the graph, with attributes
    for rendering in a force-directed graph visualization.
    """

    model_config = ConfigDict(from_attributes=True)

    id: str
    label: str = ""
    memory_type: str | None = None
    importance: float = 0.5
    tags: list[str] = Field(default_factory=list)
    is_center: bool = False
    depth: int = 0  # Distance from center node

    def model_dump_for_api(self) -> dict[str, Any]:
        """Serialize for API/visualization."""
        return {
            "id": self.id,
            "label": self.label[:50] + "..." if len(self.label) > 50 else self.label,
            "type": self.memory_type,
            "importance": self.importance,
            "tags": self.tags,
            "isCenter": self.is_center,
            "depth": self.depth,
        }


class GraphEdge(BaseModel):
    """Edge in the knowledge graph for visualization.

    Represents a relation as an edge between nodes.
    """

    model_config = ConfigDict(from_attributes=True)

    source: str
    target: str
    relation_type: RelationType
    weight: float = 1.0
    created_by: RelationCreator = RelationCreator.USER

    def model_dump_for_api(self) -> dict[str, Any]:
        """Serialize for API/visualization."""
        return {
            "source": self.source,
            "target": self.target,
            "type": self.relation_type.value,
            "weight": self.weight,
            "created_by": self.created_by.value,
        }


class Subgraph(BaseModel):
    """Subgraph extracted for visualization.

    Contains nodes and edges within a specified depth from a center node.
    """

    model_config = ConfigDict(from_attributes=True)

    center_id: str
    depth: int
    nodes: list[GraphNode] = Field(default_factory=list)
    edges: list[GraphEdge] = Field(default_factory=list)

    @property
    def node_count(self) -> int:
        """Number of nodes in subgraph."""
        return len(self.nodes)

    @property
    def edge_count(self) -> int:
        """Number of edges in subgraph."""
        return len(self.edges)

    def model_dump_for_api(self) -> dict[str, Any]:
        """Serialize for API/visualization."""
        return {
            "center": self.center_id,
            "depth": self.depth,
            "nodes": [n.model_dump_for_api() for n in self.nodes],
            "edges": [e.model_dump_for_api() for e in self.edges],
            "stats": {
                "nodeCount": self.node_count,
                "edgeCount": self.edge_count,
            },
        }


class PathStep(BaseModel):
    """A step in a path between two memories."""

    model_config = ConfigDict(from_attributes=True)

    memory_id: str
    relation_type: RelationType | None = None
    direction: str | None = None  # "in" or "out"
    memory_content: str | None = None

    def model_dump_for_api(self) -> dict[str, Any]:
        """Serialize for API responses."""
        return {
            "memory_id": self.memory_id,
            "relation": self.relation_type.value if self.relation_type else None,
            "direction": self.direction,
            "content": self.memory_content[:100] + "..."
            if self.memory_content and len(self.memory_content) > 100
            else self.memory_content,
        }


class GraphPath(BaseModel):
    """Path between two memories in the knowledge graph."""

    model_config = ConfigDict(from_attributes=True)

    from_id: str
    to_id: str
    steps: list[PathStep] = Field(default_factory=list)
    total_weight: float = 0.0

    @property
    def length(self) -> int:
        """Number of hops in the path."""
        return len(self.steps) - 1 if self.steps else 0

    @property
    def found(self) -> bool:
        """Whether a path was found."""
        return len(self.steps) > 0

    def model_dump_for_api(self) -> dict[str, Any]:
        """Serialize for API responses."""
        return {
            "from": self.from_id,
            "to": self.to_id,
            "found": self.found,
            "length": self.length,
            "steps": [s.model_dump_for_api() for s in self.steps],
            "total_weight": round(self.total_weight, 3),
        }
